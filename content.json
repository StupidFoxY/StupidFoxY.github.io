{"meta":{"title":"Tzmm的学习小总结","subtitle":"小脑袋里总记不住，看过就忘，记下来多看看","description":"紧跟前端潮流，囊括前端开发、Python开发等技术文章！","author":"Tzmm","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-06-15T02:58:41.000Z","updated":"2021-08-06T01:26:44.090Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-15T06:02:32.000Z","updated":"2021-08-06T01:26:44.102Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Nginx 部署","slug":"nginx","date":"2022-10-21T05:20:12.000Z","updated":"2023-05-16T01:38:22.139Z","comments":true,"path":"2022/10/21/nginx/","link":"","permalink":"http://yoursite.com/2022/10/21/nginx/","excerpt":"","text":"01 前言本文介绍在 ubuntu 系统下 Nginx 部署web的方式，以及多语言的部署方式。 02 部署流程(ubuntu 系统) Install NGINX from the package manager. 1sudo apt install nginx If port 80 on the firewall is closed, open port 80 on your system’s firewall. 12sudo ufw allow httpsudo ufw reload Disable the default NGINX configuration file. 1sudo unlink &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;default cope file to /var/www/. 1sudo cp -r dist&#x2F;demo&#x2F; &#x2F;var&#x2F;www&#x2F;xdemoxx.com create config file. /etc/nginx/sites-available/demo.com 123456789101112server &#123; listen 80; listen [::]:80; server_name demo.com; root &#x2F;var&#x2F;www&#x2F;demo.com; index index.html; location &#x2F; &#123; try_files $uri $uri&#x2F; &#x3D;404; &#125;&#125; Enable your NGINX site. 1sudo ln -s &#x2F;etc&#x2F;nginx&#x2F;sites-available&#x2F;demo.com &#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F; Run NGINX’s configuration test to verify your configuration file. 1sudo nginx -t Restart NGINX for the changes to take effect. 1sudo systemctl restart nginx 03 多语言的部署多语言的部署，需要对配置文件做一些改动 update config file. /etc/nginx/sites-available/xxx.com 1234567891011121314151617181920server &#123; listen 80; server_name demo.com; root &#x2F;var&#x2F;www&#x2F;demo.com; # Fallback to default language if no preference defined by browser if ($accept_language ~ &quot;^$&quot;) &#123; set $accept_language &quot;fr&quot;; &#125; # Redirect &quot;&#x2F;&quot; to Angular application in the preferred language of the browser rewrite ^&#x2F;$ &#x2F;$accept_language permanent; # Everything under the Angular application is always redirected to Angular in the # correct language location ~ ^&#x2F;(fr|de|en) &#123; try_files $uri &#x2F;$1&#x2F;index.html?$args; &#125; # ...&#125; update /etc/nginx/nginx.conf file. 12345678910http &#123; # Browser preferred language detection (does NOT require # AcceptLanguageModule) map $http_accept_language $accept_language &#123; ~*^de de; ~*^fr fr; ~*^en en; &#125; # ...&#125; 04 Nginx 命令 View the current status of the NGINX service using the command below: 1sudo systemctl status nginx Stop the NGINX service with the following command: 1sudo systemctl stop nginx You can then start the NGINX service back up using the following command: 1sudo systemctl start nginx To disable the NGINX service, preventing it from beginning automatically at system startup, execute the following: 1sudo systemctl disable nginx You can enable the NGINX service again using: 1sudo systemctl enable nginx Restart the NGINX service using the command below: 1sudo systemctl restart nginx To reload NGINX’s configuration files, you an use the following command: 1sudo systemctl reload nginx 05 部署流程(centOS 系统) 安装Nginx相关依赖. 1sudo yum -y install gcc gcc-c++ make libtool zlib zlib-devel openssl openssl-devel pcre pcre-devel 下载nginx.tar.gz安装包 nginx:dowload.html 1sudo wget -c https:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.18.0.tar.gz 解压，配置. 123tar -zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0.&#x2F;configure 编译安装 12makesudo make install 启动Nginx 12# 启动sudo &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx cope file to /var/www/. 12sudo cp -r dist&#x2F;web-client&#x2F; &#x2F;var&#x2F;www&#x2F;cogenda-cloudsudo cp -r dist&#x2F;web-manager&#x2F; &#x2F;var&#x2F;www&#x2F;cogenda-cloud update /usr/local/nginx/conf/nginx.conf file. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051http &#123; # Browser preferred language detection (does NOT require # AcceptLanguageModule) map $http_accept_language $accept_language &#123; ~*^zh-CN zh-CN; ~*^en-US en-US; &#125; # ...&#125;#web-clientserver &#123; listen 8080; server_name web-client; root &#x2F;var&#x2F;www&#x2F;cogenda-cloud&#x2F;web-client; # Fallback to default language if no preference defined by browser if ($accept_language ~ &quot;^$&quot;) &#123; set $accept_language &quot;en-US&quot;; &#125; # Redirect &quot;&#x2F;&quot; to Angular application in the preferred language of the browser rewrite ^&#x2F;$ &#x2F;$accept_language permanent; # Everything under the Angular application is always redirected to Angular in the # correct language location ~ ^&#x2F;(zh-CN|en-US) &#123; try_files $uri &#x2F;$1&#x2F;index.html?$args; &#125;&#125;#web-managerserver &#123; listen 8090; server_name web-manager; root &#x2F;var&#x2F;www&#x2F;cogenda-cloud&#x2F;web-manager; # Fallback to default language if no preference defined by browser if ($accept_language ~ &quot;^$&quot;) &#123; set $accept_language &quot;en-US&quot;; &#125; # Redirect &quot;&#x2F;&quot; to Angular application in the preferred language of the browser rewrite ^&#x2F;$ &#x2F;$accept_language permanent; # Everything under the Angular application is always redirected to Angular in the # correct language location ~ ^&#x2F;(zh-CN|en-US) &#123; try_files $uri &#x2F;$1&#x2F;index.html?$args; &#125;&#125; restart Nginx. 1sudo &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload 新增端口 12345sudo yum install firewalld #安装动态防火墙管理工具sudo systemctl start firewalld #启动sudo firewall-cmd --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp --permanent #永久增加端口，重启也有效sudo firewall-cmd --zone&#x3D;public --add-port&#x3D;8090&#x2F;tcp --permanentsudo firewall-cmd --reload #重启 设置开机启动Nginx 12345678cd &#x2F;etc&#x2F;sudo vim rc.local#增加一行&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx#保存并退出vim 执行chmod 755 rc.local","categories":[{"name":"进阶应用","slug":"进阶应用","permalink":"http://yoursite.com/categories/%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://yoursite.com/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"Generator 函数","slug":"generator","date":"2021-12-03T01:34:40.000Z","updated":"2021-12-03T07:45:17.727Z","comments":true,"path":"2021/12/03/generator/","link":"","permalink":"http://yoursite.com/2021/12/03/generator/","excerpt":"","text":"前言Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本文将详细介绍 Generator 函数的语法和 API。 01 基本概念语法上，Generator 函数可以理解为一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。所以 Generator 函数还是一个遍历器对象生成函数。 形式上，Generator 函数与普通函数差别不大，但是有两个特征： function 关键字与函数名之间有一个星号 函数体内部使用 yield 表达式，定义不同的内部状态 1234567function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;let hw = helloWorldGenerator(); 上面代码定义了一个 Generator 函数 helloWorldGenerator，它内部有两个 yield 表达式（hello 和 world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。 Generator 函数的调用方法与普通函数一样。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。 下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止。 换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。 1234567891011hw.next();// &#123; value: 'hello', done: false &#125;hw.next();// &#123; value: 'world', done: false &#125;hw.next();// &#123; value: 'ending', done: true &#125;hw.next();// &#123; value: undefined, done: true &#125; 上面代码一共调用了四次 next 方法。每次调用 next 方法，都会返回一个有 value 和 done 两个属性的对象。 value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值 done 属性是一个布尔值，表示是否遍历结束 ES6 没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。 1234function * foo(x, y) &#123; ··· &#125;function *foo(x, y) &#123; ··· &#125;function* foo(x, y) &#123; ··· &#125;function*foo(x, y) &#123; ··· &#125; 由于 Generator 函数仍然是普通函数，所以会采用第三种写法。 当 Generator 函数作为对象的属性时，可以采用一下两种写法。 123456789101112let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;;//等价于let obj = &#123; myGeneratorMethod: function* () &#123; // ··· &#125;&#125;; 02 yield 表达式由于 Generator 函数返回的遍历器对象，只有调用 next 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。而 yield 表达式就是暂停标志。 遍历器对象的 next 方法的运行逻辑如下： 遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。 下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。 如果不在存在 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。 如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined。 基于这种运行逻辑，Generator 函数为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 另外需要注意，yield 表达式只能用在 Generator 函数里面，用在其他地方都会报错。 1234(function ()&#123; yield 1;&#125;)()// SyntaxError: Unexpected number 另一个例子 123456789101112let arr = [1,2,3,4,5];let flat = function* (a)&#123; a.forEach((item)=&gt;&#123; yield item; &#125;)&#125;for (let f of flat(arr))&#123; console.log(f);&#125;//Uncaught SyntaxError: Unexpected identifier 上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield表达式，改用for循环就能解决此问题。 123456789101112let arr = [1,2,3,4,5];let flat = function* (a)&#123; for(let i = 0; i &lt; a.length; i++)&#123; yield a[i]; &#125;&#125;for (let f of flat(arr))&#123; console.log(f);&#125;//1, 2, 3, 4, 5 另外，yield 表达式如果用在另一个表达式之中，必须放在圆括号里面。但 yield 表达式用作函数参数或放在赋值表达式的右边，可以不加括号。 12345678910function* demo() &#123; console.log('Hello' + yield); // SyntaxError console.log('Hello' + yield 123); // SyntaxError console.log('Hello' + (yield)); // OK console.log('Hello' + (yield 123)); // OK foo(yield 'a', yield 'b'); // OK let input = yield; // OK&#125; 与Iterator接口的关系任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] 另外 Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性。 12345678910function* gen() &#123; yield 1; yield 2; yield 3; return 4;&#125;;let g = gen();[...g] // [1, 2, 3] 这里需要注意，一旦 next 方法的返回对象的 done 属性为true，遍历器就会中止，且不包含该返回对象，所以上面代码的 return 语句返回的4不在结构赋值...g的循环中。 for...of循环也是同理。另外原生的 JavaScript 对象没有遍历接口，无法使用 for…of 循环，通过 Generator 函数为它加上这个接口，就可以用了。 12345678910111213141516function* objectEntries(obj) &#123; let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) &#123; yield [propKey, obj[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;for (let [key, value] of objectEntries(jane)) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 另一种写法是将 Generator 函数加到对象的Symbol.iterator属性上面。 1234567891011121314151617function* objectEntries() &#123; let propKeys = Object.keys(this); for (let propKey of propKeys) &#123; yield [propKey, this[propKey]]; &#125;&#125;let jane = &#123; first: 'Jane', last: 'Doe' &#125;;jane[Symbol.iterator] = objectEntries;for (let [key, value] of jane) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// first: Jane// last: Doe 03 next 方法yield 表达式本身没有返回值，或者说总是返回undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next()方法的参数，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 123456789101112131415function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; 上面代码中，a 的第二次运行步骤如下： 第一次调用 next 方法的时候不带参数，返回x+1的值6 第二次调用 next 方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），y / 3 的值为NaN，返回对象的 value 属性也等于NaN。 第三次调用 next 方法的时候不带参数，导致 z 等于undefined，返回对象的 value 属性等于5 + NaN + undefined，即NaN。 而 b 的运行就不一样了： 第一次调用 next 方法的时候不带参数，返回x+1的值6 第二次调用 next 方法，将上一次 yield 表达式的值设为12，因此 y 等于2 * 12，即24。y / 3 的值为8，返回对象的 value 属性也等于8。 第三次调用 next 方法，将上一次 yield 表达式的值设为13，因此 z 等于13，返回对象的 value 属性等于5 + 8 + 13,即42。 注意，由于 next 方法的参数表示上一个 yield 表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用 next 方法时的参数，只有从第二次使用 next 方法开始，参数才是有效的。 04 throw 方法Generator 函数返回的遍历器对象，都有一个throw()方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。 12345678910111213141516171819var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 内部捕获 a// 外部捕获 b 上面代码中，遍历器对象 i 连续抛出两个错误。第一个错误被 Generator 函数体内的 catch 语句捕获。i 第二次抛出错误，由于 Generator 函数内部的catch 语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的 catch 语句捕获。 throw 方法可以接受一个参数，该参数会被 catch 语句接收，建议抛出Error对象的实例。 如果 Generator 函数内部没有部署try...catch代码块，那么 throw 方法抛出的错误，将被外部 try…catch 代码块捕获。 1234567891011121314151617var g = function* () &#123; while (true) &#123; yield; console.log('内部捕获', e); &#125;&#125;;var i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 a 如果 Generator 函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。 12345678910var gen = function* gen()&#123; yield console.log('hello'); yield console.log('world');&#125;var g = gen();g.next();g.throw();// hello// Uncaught undefined 另外 throw 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 next 方法。 1234567891011121314151617var g = function* () &#123; try &#123; yield; &#125; catch (e) &#123; console.log('内部捕获', e); &#125;&#125;;var i = g();try &#123; i.throw('a'); i.throw('b');&#125; catch (e) &#123; console.log('外部捕获', e);&#125;// 外部捕获 a throw 方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。 1234567891011121314var gen = function* gen()&#123; try &#123; yield console.log('a'); &#125; catch (e) &#123; // ... &#125; yield console.log('b'); yield console.log('c');&#125;var g = gen();g.next() // ag.throw() // bg.next() // c Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的 catch 捕获。 一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next 方法，将返回一个value属性等于undefined、done属性等于true的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344function* g() &#123; yield 1; console.log('throwing an exception'); throw new Error('generator broke!'); yield 2; yield 3;&#125;function log(generator) &#123; var v; console.log('starting generator'); try &#123; v = generator.next(); console.log('第一次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第二次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; try &#123; v = generator.next(); console.log('第三次运行next方法', v); &#125; catch (err) &#123; console.log('捕捉错误', v); &#125; console.log('caller done');&#125;log(g());// starting generator// 第一次运行next方法 &#123; value: 1, done: false &#125;// throwing an exception// 捕捉错误 &#123; value: 1, done: false &#125;// 第三次运行next方法 &#123; value: undefined, done: true &#125;// caller done 05 return 方法Generator 函数返回的遍历器对象，还有一个return()方法，可以返回给定的值，并且终结遍历 Generator 函数。 1234567891011function* gen() &#123; yield 1; yield 2; yield 3;&#125;var g = gen();g.next() // &#123; value: 1, done: false &#125;g.return('foo') // &#123; value: \"foo\", done: true &#125;g.next() // &#123; value: undefined, done: true &#125; 如果return()方法调用时，不提供参数，则返回值的value属性为undefined。 如果 Generator 函数内部有try...finally代码块，且正在执行 try 代码块，那么return()方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束。 1234567891011121314151617function* numbers () &#123; yield 1; try &#123; yield 2; yield 3; &#125; finally &#123; yield 4; yield 5; &#125; yield 6;&#125;var g = numbers();g.next() // &#123; value: 1, done: false &#125;g.next() // &#123; value: 2, done: false &#125;g.return(7) // &#123; value: 4, done: false &#125;g.next() // &#123; value: 5, done: false &#125;g.next() // &#123; value: 7, done: true &#125; 06 yield* 表达式如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。 ES6 提供了yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。 123456789101112131415161718192021222324252627function* foo() &#123; yield 'a'; yield 'b';&#125;function* bar() &#123; yield 'x'; yield* foo(); yield 'y';&#125;// 等同于function* bar() &#123; yield 'x'; for (let f of foo()) &#123; yield f; &#125; yield 'y';&#125;for (let i of bar())&#123; console.log(i);&#125;// \"x\"// \"a\"// \"b\"// \"y\" 上面代码说明，yield*后面的 Generator 函数（没有return语句时），不过是for...of的一种简写形式，完全可以用后者替代前者。反之，在有return语句时，则需要用var value = yield* iterator的形式获取return语句的值。 简单来说yield*是对任何数据结构只要有 Iterator 接口遍历的语法糖。 07 Generator 函数中的 this由于 Generator 函数返回的是遍历器对象，不是this对象，因此 Generator 函数也不能跟new命令一起用，会报错。 12345678910function* F() &#123; yield this.x = 2; yield this.y = 3;&#125;let obj = F();obj.next(); //&#123;value: 2, done: false&#125;obj.a // undefinednew F() // TypeError: F is not a constructor 当让也不是没有办法解决此问题，下面是一个变通方法。首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。 123456789101112131415function* F() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;var obj = &#123;&#125;;var f = F.call(obj);f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;obj.a // 1obj.b // 2obj.c // 3 上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，这样代码的可读性显然不好。 一个办法就是将obj换成F.prototype，再将F改成构造函数，就可以对它执行new命令了。 12345678910111213141516171819function* gen() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 08 总结Generator 函数是 ES6 提供的一种异步编程解决方案。返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上采用 function 关键字与函数名之间有一个星号，函数体内部使用yield表达式，定义不同的内部状态。 next()、throw()、return()这三个方法本质上是同一件事，作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。 next()是将yield表达式替换成一个值。 throw()是将yield表达式替换成一个throw语句。 return()是将yield表达式替换成一个return语句。 yield*表达式，本质上是对具有Iterator接口的任何数据结构进行遍历，可以用来简化在一个 Generator 函数里面执行另一个 Generator 函数的写法。 而Generator 函数由于返回的是遍历器对象，不是this对象，因此不能与new命令一起使用，可以采用call方法 Generator 函数内部的this方法解决。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"WebAssembly[未完成]","slug":"webassembly","date":"2021-09-10T02:54:12.000Z","updated":"2022-10-21T05:30:57.102Z","comments":true,"path":"2021/09/10/webassembly/","link":"","permalink":"http://yoursite.com/2021/09/10/webassembly/","excerpt":"","text":"01 什么是 WebAssemblyWebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行。它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C/C ++ 等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。 02 如何使用 WebAssembly简单来说要使用WebAssembly，主要分为两步： 从 C/C++ 等语言编译为 WebAssembly 加载运行 WebAssembly 下图是 C/C++ 语言编译为 WebAssembly 在 Web 项目中运行的流程。下面详细介绍 Linux 如何应用。 WebAssembly 流程 编译编译需要使用 Emscripten 将 C/C++ 之类的语言所编写模块编译到WebAssembly。 Emscripten 环境安装需要通过源码自己编译一个 Emscripten。运行下列命令来自动化地使用 Emscripten SDK。 1234567git clone https:&#x2F;&#x2F;github.com&#x2F;juj&#x2F;emsdk.gitcd emsdk.&#x2F;emsdk install latest.&#x2F;emsdk activate latest --globalsource .&#x2F;emsdk_env.sh 注意: –global 标识会让PATH变量在全局被设置，所以接下来所打开的终端或者命令行窗口都会被设置。如果您仅仅想让 Emscripten 在当前窗口生效，就删掉这个标识。 注意: 每当您想要使用 Emscripten 时，尝试从远程更新最新的 Emscripten 代码是个很好的习惯（运行 git pull）。如果有更新，重新执行 install 和 activate 命令。这样就可以确保您使用的 Emscripten 一直保持最新。 将 C 编译为 WebAssembly以著名的斐波那契数列为例 /wasm/fibonacci.c 123456789#include &lt;emscripten.h&gt;int EMSCRIPTEN_KEEPALIVE fibonacci(int n)&#123; if (n == 0 || n == 1) return n; else return (fibonacci(n - 1) + fibonacci(n - 2));&#125; 在一个已经配置过 Emscripten 编译环境的终端窗口中以下命令 1emcc wasm&#x2F;fibonacci.c -Os -s WASM&#x3D;1 -s MODULARIZE&#x3D;1 -o wasm&#x2F;fibonacci.js -Os - 定义执行的优化等级，我们在这里使用了相当高的等级。 -s WASM=1 - 指定我们想要的wasm输出形式。如果我们不指定这个选项，Emscripten 默认将只会生成 asm.js。 -s MODULARIZE=1 - 除了 WASM，编译器还会生成一个 JavaScript 文件。该文件包含一些粘合代码，用于处理 WASM 和 JavaScript 之间的通信。使用 MODULARIZE=1 选项，我们告诉编译器将该代码包装到一个模块中。方便后续在 Angular 中使用。 -o wasm/fibonacci.js - 定义输出文件。 加载与运行WebAssembly 还没有和 或 ES6 的 impor t语句集成，也就是说，当前还没有内置的方式让浏览器为你获取模块。当前唯一的方式就是创建一个包含你的 WebAssembly 模块二进制代码的 ArrayBuffer 并且使用 WebAssembly.instantiate() 编译它。 使用FetchFetch 是一个用来获取网络资源的方便现代的 API。 假设网络上有一个叫做 simple.wasm 的 WebAssembly 模块： 我们可以使用fetch()全局函数来轻松地获取它，该函数返回一个可以解析为Response对象的promise。 我们可以使用arrayBuffer()函数把响应（response）转换为带类型数组，该函数返回一个可以解析为带类型数组的promise。 最后，我们使用WebAssembly.instantiate()函数一步实现编译和实例化带类型数组。 代码块看起来像这样： 1234567fetch('module.wasm').then(response =&gt; response.arrayBuffer()).then(bytes =&gt; WebAssembly.instantiate(bytes, importObject)).then(results =&gt; &#123; // Do something with the compiled results!&#125;); 注意： WebAssembly.instantiate不是获取(fetch)和实例化wasm模块的最具效率方法。 如果可能的话，您应该改用较新的WebAssembly.instantiateStreaming()方法，该方法直接从原始字节码中直接获取，编译和实例化模块，因此不需要转换为ArrayBuffer。 使用 WebAssembly.instantiateStreaming: 12345WebAssembly.instantiateStreaming(fetch('simple.wasm'), importObject).then(results =&gt; &#123; // Do something with the compiled results! results.instance.exports.exported_func();&#125;);","categories":[{"name":"进阶应用","slug":"进阶应用","permalink":"http://yoursite.com/categories/%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8/"}],"tags":[{"name":"应用","slug":"应用","permalink":"http://yoursite.com/tags/%E5%BA%94%E7%94%A8/"}]},{"title":"JavaScript的执行上下文和执行栈[未完成]","slug":"execution-context","date":"2021-08-09T05:53:10.000Z","updated":"2021-12-03T07:02:43.409Z","comments":true,"path":"2021/08/09/execution-context/","link":"","permalink":"http://yoursite.com/2021/08/09/execution-context/","excerpt":"","text":"执行上下文是当前 JavaScript 代码被解析和执行时所在环境的抽象概念。 01 执行上下文的类型执行上下文总共有三种类型 全局执行上下文：只有一个，浏览器中的全局对象就是 window 对象，this 指向这个全局对象。 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。 Eval 函数执行上下文：指的是运行在 eval 函数中的代码，很少用而且不建议使用。 02 执行栈执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文。 首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。 根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。 1234567891011121314var a = 'Hello World!';function first() &#123; console.log('Inside first function'); second(); console.log('Again inside first function'); &#125;function second() &#123; console.log('Inside second function'); &#125;first(); console.log('Inside Global Execution Context'); 执行栈 03执行上下文的创建执行上下文分两个阶段创建： 创建阶段 执行阶段 创建阶段创建阶段一共三个步骤： 确定 this 的值，也被称为 This Binding。 词法环境（LexicalEnvironment） 组件被创建。 变量环境（VariableEnvironment） 组件被创建。 This Binding 全局执行上下文中，this 的值指向全局对象，在浏览器中 this 的值指向 window对象，而在 nodejs 中指向这个文件的 module对象。 函数执行上下文中，this 的值取决于函数的调用方式。具体有：默认绑定、隐式绑定、显式绑定（硬绑定）、new绑定、箭头函数等。 词法环境（LexicalEnvironment） 词法环境由两个组成部分： 环境记录：存储变量和函数声明的实际位置 对外部环境的引用：可以访问其外部词法环境 词法环境有两种情况： 全局环境：在全局环境下，词法环境对其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。 123456789101112131415161718192021// 伪代码// 全局执行上下文GlobalExectionContext = &#123; LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: \"Object\", // 标识符绑定在这里 outer: &lt;null&gt; // 对外部环境的引用 &#125; &#125;// 函数执行上下文FunctionExectionContext = &#123; LexicalEnvironment: &#123; // 词法环境 EnvironmentRecord: &#123; // 环境记录 Type: \"Declarative\", // 标识符绑定在这里 outer: &lt;Global or outer function environment reference&gt; // 对外部环境的引用 &#125; &#125; 变量环境（VariableEnvironment）","categories":[{"name":"V8引擎工作原理","slug":"V8引擎工作原理","permalink":"http://yoursite.com/categories/V8%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}],"tags":[]},{"title":"浏览器的原理相关知识点","slug":"browser","date":"2021-08-06T01:26:44.086Z","updated":"2021-12-03T01:41:57.461Z","comments":true,"path":"2021/08/06/browser/","link":"","permalink":"http://yoursite.com/2021/08/06/browser/","excerpt":"","text":"01 前言作为一个合格的前端工程师，浏览器相关的工作原理是我们进行性能优化的基石，了解浏览器原理也是前端系统知识体系中的重要一环。 本文内容将会囊括浏览器的缓存，浏览器的访问流程，浏览器的本地存储，浏览器的安全问题，浏览器的跨域问题，HTTP/HTTPS/TCP/IP/UDP的区别 02 目录 常见浏览器内核 浏览器的主要组成 浏览器的缓存 浏览器的访问流程 浏览器的本地存储 浏览器的安全问题 XSS攻击 CSRF攻击 浏览器的跨域问题 HTTP/HTTPS/TCP/IP/UDP的区别 03 常见浏览器内核 浏览器/RunTime 内核（渲染引擎） Chrome webkit -&gt; blink FireFox Gecko Safari Webkit IE Trident Edge EdgeHTML Opera Presto -&gt; blink 04 浏览器的主要组成 「用户界面」 - 包括地址栏、前进/后退按钮、书签菜单等。 「浏览器引擎」 - 在用户界面和呈现引擎之间传送指令。 「呈现引擎」 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 「网络」 - 用于网络调用，比如 HTTP 请求。「用户界面后端」 -用于绘制基本的窗口小部件，比如组合框和窗口。 「JavaScript 解释器」- 用于解析和执行 JavaScript 代码。 「数据存储」 - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。 值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"浏览器工作原理","slug":"浏览器工作原理","permalink":"http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"}]},{"title":"谈谈闭包的知识点","slug":"closure","date":"2021-08-06T01:26:44.086Z","updated":"2021-08-06T02:02:24.607Z","comments":true,"path":"2021/08/06/closure/","link":"","permalink":"http://yoursite.com/2021/08/06/closure/","excerpt":"","text":"01 前言闭包知识点是很基础的，是面试的基础题。忙着去学习前端框架等其他技术，却常常忘记了最基础的内容。本篇文章简单介绍了什么是闭包，以及闭包的优缺点。 02 什么是闭包闭包：函数A内部有函数B，函数B可以访问函数A的变量，那么函数B就是闭包。 12345678function A()&#123; var a = 123; function B()&#123; console.log(a) //123 &#125; return B()&#125;A()(); 03 闭包的特性以及优缺点闭包特性： 函数嵌套函数 子函数内部可以调用外部父函数的变量和参数 当父函数执行完毕时，被子函数调用到的参数和变量不会被垃圾回收机制回收 闭包的优点： 可读取函数内部的变量 局部变量可以保存在内存中，实现数据共享 执行过程所有变量都匿名在函数内部 闭包的缺点： 局部变量长期存在内存中，内存消耗大 滥用闭包可能会导致内存泄漏 闭包可以在父函数外部改变父函数内部的值","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"易考点","slug":"易考点","permalink":"http://yoursite.com/tags/%E6%98%93%E8%80%83%E7%82%B9/"}]},{"title":"函数的防抖与节流","slug":"debounce-throttle","date":"2020-12-03T08:48:30.000Z","updated":"2021-09-10T02:56:58.088Z","comments":true,"path":"2020/12/03/debounce-throttle/","link":"","permalink":"http://yoursite.com/2020/12/03/debounce-throttle/","excerpt":"","text":"01 前言防抖和节流严格算起来应该属于性能优化的知识，但实际在开发过程中频率还是相当高的，放任不管或者处理不当就容易引起浪费计算机资源，降低程序运行速度，甚至造成浏览器卡死、崩溃。这种问题显然是致命的。 02 场景举例：input框搜索input框搜索是一个很多网站都常见的功能，输入内容即刻就显示搜索结果。 「实现」 12345document.querySelector('#search').addEventListener(\"input\",search());function search()&#123; console.log('search:'+Math.random())&#125; 在运行时我们会发现，search函数的执行频率太高了，每次输入都会触发。但绝大多数时候我们都是在输入的过程中，并非是我们想要搜索的内容。因此我们就需要优化这种使用场景。 03 防抖防抖（debounce），就是指触发事件后，在 n 秒内函数只能执行一次，如果触发事件后在 n 秒内又触发了事件，则会重新计算函数延执行时间。 基于上述场景，我们需要给出一个期限值，如200ms： 如果在200ms内没有再次触发输入事件，那么就执行搜索功能 如果再200ms内再次触发了输入事件，那么就取消当前计时，重新开始计时 「实现」 123456789101112131415document.querySelector('#search').addEventListener(\"input\",debounce(search,200));function debounce(fn,delay)&#123; var timer = null; return function()&#123; if(timer)&#123; clearTimeout(timer); &#125; timer = setTimeout(fn,delay); &#125;&#125;function search()&#123; console.log(Math.random());&#125; 04 节流节流（throttle），就是指触发事件后，在 n 秒内函数只能执行一次，如果触发事件后在 n 秒内又触发了事件，则会无效。 基于上述防抖的效果看，如果用户一直不停的触发输入事件，理论上就永远不会进行搜索功能。 那么我们就需要考虑另一种方案，同样是200ms的期望值： 在持续触发输入事件时，每隔200ms就会执行一次搜索功能 「实现」 12345678910111213141516171819document.querySelector('#search').addEventListener(\"input\",throttle(search,200));function throttle(fn,delay)&#123; var valid = true; return function()&#123; if(!valid)&#123; return false; &#125; valid = false setTimeout(()=&gt;&#123; fn(); valid = true; &#125;,delay) &#125;&#125;function search()&#123; console.log(Math.random());&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"易考点","slug":"易考点","permalink":"http://yoursite.com/tags/%E6%98%93%E8%80%83%E7%82%B9/"},{"name":"应用","slug":"应用","permalink":"http://yoursite.com/tags/%E5%BA%94%E7%94%A8/"}]},{"title":"JS获取屏幕的宽高","slug":"screen-width-height","date":"2020-10-30T06:40:55.000Z","updated":"2021-09-10T02:57:18.107Z","comments":true,"path":"2020/10/30/screen-width-height/","link":"","permalink":"http://yoursite.com/2020/10/30/screen-width-height/","excerpt":"","text":"01 前言JS获取屏幕的宽高，主要跟JS的offset、client、scroll属性有关，他们各自有何区别，本文将详细介绍。 02 offset家族​偏移量(offset dimension)是javascript中的一个重要的概念。涉及到偏移量的主要是offsetLeft、offsetTop、offsetHeight、offsetWidth这四个属性。当然，还有一个偏移参照——定位父级offsetParent。 offset家族 offsetParent​offsetParent（定位父级）的定义是：与当前元素最近的经过定位(position不等于static)的父级元素，主要分为下列几种情况： 元素自身有fixed定位，offsetParent的结果为null 123456&lt;div id=\"test\" style=\"position:fixed\"&gt;&lt;/div&gt; &lt;script&gt; var test = document.getElementById('test'); console.log(test.offsetParent); //firefox并没有考虑固定定位的问题，返回&lt;body&gt;，其他浏览器都返回null&lt;/script&gt; 元素自身无fixed定位，offsetParent为离该元素最近的进行过定位的父元素，如果其父元素不存在，定位父级则为&lt;body&gt; 12345678910111213&lt;div id=\"grandfather\" style=\"position: relative;\"&gt; &lt;div id=\"father\" &gt; &lt;div id=\"test1\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=\"test2\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var test1 = document.getElementById('test1'); console.log(test1.offsetParent);//&lt;div id=\"grandfather\"&gt; var test2 = document.getElementById('test2'); console.log(test2.offsetParent);//&lt;body&gt;&lt;/script&gt; &lt;body&gt;元素的offsetParent是null 1console.log(document.body.offsetParent);//null offsetWidth​offsetWidth表示元素在水平方向上占用的空间大小，无单位(以像素px计) 1offsetWidth = border-left-width + padding-left + width + padding-right + border-right-width; offsetHeightoffsetHeight表示元素在垂直方向上占用的空间大小，无单位(以像素px计) 1offsetHeight = border-top-width + padding-top + height + padding-bottom + border-bottom-width offsetTopoffsetTop表示元素的上外边框至offsetParent元素的上内边框之间的像素距离 offsetLeftoffsetLeft表示元素的左外边框至offsetParent元素的左内边框之间的像素距离 03 client家族client（客户区域）指的是元素内容及其内边距所占据的空间大小。家族成员主要有clientWidth,clientHeight,clientTop,clientLeft。 client家族 clientWidthclientWidth属性返回元素节点的客户区宽度 1clientWidth = padding-left + width + padding-right clientHeightclientHeight属性返回元素节点的客户区高度 1clientHeight = padding-top + height + padding-bottom clientTopclientTop属性返回上边框的宽度 clientLeftclientLeft属性返回左边框的宽度 注意点 页面大小常用document.documentElement的client属性来表示页面大小(不包含滚动条宽度) 12document.documentElement.clientWidth //可见区域宽度 document.documentElement.clientHeight //可见区域高度 所有的client属性都是只读的 如果给元素设置了display:none，则客户区client属性都为0 每次访问客户区client属性都需要重新计算，重复访问需要耗费大量的性能，所以要尽量避免重复访问这些属性。 04 scroll家族scroll顾名思义与滚动相关，同样家族包括scrollWidth,scrollHeight,scrollTop,scrollLeft。 scrollWidthscrollWidth表示元素的总宽度，包括由于溢出而无法展示在网页的不可见部分。没有滚动条时，scrollWidth与clientWidth属性结果相等 scrollHeightscrollHeight表示元素的总高度，包括由于溢出而无法展示在网页的不可见部分。没有滚动条时，scrollHeight与clientHeight属性结果相等 scrollTopscrollTop属性表示被隐藏在内容区域上方的像素数。元素未滚动时，scrollTop的值为0，如果元素被垂直滚动了，scrollTop的值大于0，表示元素上方不可见内容的像素高度。当滚动条滚动到内容底部时，符合以下等式 1scrollHeight = scrollTop + clientHight scrollLeftscrollLeft属性表示被隐藏在内容区域左侧的像素数。元素未滚动时，scrollLeft的值为0，如果元素被水平滚动了，scrollLeft的值大于0，且表示元素左侧不可见内容的像素宽度。与scrollHeight和scrollWidth属性不同的是，scrollLeft和scrollTop是可写的。 应用：回到顶部12345678var backTop = document.getElementById('backTop');backTop.onclick = scrollTop;function scrollTop()&#123; //兼容性写法 if(document.documentElement.scrollTop || document.body.scrollTop)&#123; document.documentElement.scrollTop = document.body.scrollTop = 0; &#125;&#125; 应用：scrollTo()方法12345var backTop = document.getElementById('backTop');backTop.onclick = scrollTop;function scrollTop()&#123; scrollTo(0,0);&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"应用","slug":"应用","permalink":"http://yoursite.com/tags/%E5%BA%94%E7%94%A8/"},{"name":"转载","slug":"转载","permalink":"http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"ES6数组的扩展","slug":"es6-array","date":"2020-10-30T02:18:13.000Z","updated":"2021-12-03T01:42:52.171Z","comments":true,"path":"2020/10/30/es6-array/","link":"","permalink":"http://yoursite.com/2020/10/30/es6-array/","excerpt":"","text":"01 扩展运算符含义扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 该运算符主要用于函数调用。 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们都使用了扩展运算符。该运算符将一个数组，变为参数序列。 扩展运算符与正常的函数参数可以结合使用，非常灵活。 123function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]); 扩展运算符后面还可以放置表达式。 1234const arr = [ ...(x &gt; 0 ? ['a'] : []), 'b',]; 如果扩展运算符后面是一个空数组，则不产生任何效果。 12[...[], 1]// [1] 注意，只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。 12345678(...[1, 2])// Uncaught SyntaxError: Unexpected numberconsole.log((...[1, 2]))// Uncaught SyntaxError: Unexpected numberconsole.log(...[1, 2])// 1 2 上面三种情况，扩展运算符都放在圆括号里面，但是前两种情况会报错，因为扩展运算符所在的括号不是函数调用。 替代函数的 apply 方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 12345678910111213// ES5 的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;let args = [0, 1, 2];f(...args); 下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。 12345678// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。 另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。 123456789// ES5的 写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);// ES6 的写法let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];arr1.push(...arr2); 上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。 下面是另外一个例子。 1234// ES5new (Date.bind.apply(Date, [null, 2015, 1, 1]))// ES6new Date(...[2015, 1, 1]); 扩展运算符的应用（1）复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 12345const a1 = [1, 2];const a2 = a1;a2[0] = 2;a1 // [2, 2] 上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。 ES5 只能用变通方法来复制数组。 12345const a1 = [1, 2];const a2 = a1.concat();a2[0] = 2;a1 // [1, 2] 上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。 扩展运算符提供了复制数组的简便写法。 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 上面的两种写法，a2都是a1的克隆。 （2）合并数组 扩展运算符提供了数组合并的新写法。 1234567891011const arr1 = ['a', 'b'];const arr2 = ['c'];const arr3 = ['d', 'e'];// ES5 的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 不过，这两种方法都是浅拷贝，使用的时候需要注意。 12345678const a1 = [&#123; foo: 1 &#125;];const a2 = [&#123; bar: 2 &#125;];const a3 = a1.concat(a2);const a4 = [...a1, ...a2];a3[0] === a1[0] // truea4[0] === a1[0] // true 上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。 （3）与解构赋值结合 扩展运算符可以与解构赋值结合起来，用于生成数组。 1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 下面是另外一些例子。 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [\"foo\"];first // \"foo\"rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 （4）字符串 扩展运算符还可以将字符串转为真正的数组。 12[...'hello']// [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。 12'x\\uD83D\\uDE80y'.length // 4[...'x\\uD83D\\uDE80y'].length // 3 上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。 12345function length(str) &#123; return [...str].length;&#125;length('x\\uD83D\\uDE80y') // 3 凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。 1234567let str = 'x\\uD83D\\uDE80y';str.split('').reverse().join('')// 'y\\uDE80\\uD83Dx'[...str].reverse().join('')// 'y\\uD83D\\uDE80x' 上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。 （5）实现了 Iterator 接口的对象 任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 12let nodeList = document.querySelectorAll('div');let array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个NodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。 123456789Number.prototype[Symbol.iterator] = function*() &#123; let i = 0; let num = this.valueOf(); while (i &lt; num) &#123; yield i++; &#125;&#125;console.log([...5]) // [0, 1, 2, 3, 4] 上面代码中，先定义了Number对象的遍历器接口，扩展运算符将5自动转成Number实例以后，就会调用这个接口，就会返回自定义的结果。 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 123456789let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// TypeError: Cannot spread non-iterable object.let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 （6）Map 和 Set 结构，Generator 函数 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 1234567let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567const go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。 12const obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object 02 Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用filter方法。 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。 12345Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b'] 上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。 12Array.from([1, 2, 3])// [1, 2, 3] 值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。 1234567// arguments对象function foo() &#123; const args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 下面的例子是取出一组 DOM 节点的文本内容。 1234567let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent) 下面的例子将数组中布尔值为false的成员转为0。 12Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3] 另一个例子是返回各种数据的类型。 12345function typesOf () &#123; return Array.from(arguments, value =&gt; typeof value)&#125;typesOf(null, [], NaN)// ['object', 'object', 'number'] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。 12Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] 上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。 Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\\uFFFF的 Unicode 字符，算作两个字符的 bug。 123function countSymbols(string) &#123; return Array.from(string).length;&#125; 03 Array.of()Array.of方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 Array.of方法可以用下面的代码模拟实现。 123function ArrayOf()&#123; return [].slice.call(arguments);&#125; 04 实例方法: copyWithin()数组实例的copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。 这三个参数都应该是数值，如果不是，会自动转为数值。 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。 下面是更多例子。 123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 05 实例方法: find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 上面代码找出数组中第一个小于 0 的成员。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 12345function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: 'John', age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。 另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 06 实例方法: fill()fill方法使用给定值，填充一个数组。 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 123456789let arr = new Array(3).fill(&#123;name: \"Mike\"&#125;);arr[0].name = \"Ben\";arr// [&#123;name: \"Ben\"&#125;, &#123;name: \"Ben\"&#125;, &#123;name: \"Ben\"&#125;]let arr = new Array(3).fill([]);arr[0].push(5);arr// [[5], [5], [5]] 07 实例方法: entries()，keys() 和 values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。 12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 08 实例方法: includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。 123if (arr.indexOf(el) !== -1) &#123; // ...&#125; indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 12[NaN].indexOf(NaN)// -1 includes使用的是不一样的判断算法，就没有这个问题。 12[NaN].includes(NaN)// true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。 123456const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false 另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。 Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。 Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 09 实例方法: flat()，flatMap()数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 12[1, 2, [3, 4]].flat()// [1, 2, 3, 4] 上面代码中，原数组的成员里面有一个数组，flat()方法将子数组的成员取出来，添加在原来的位置。 flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。 12345[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5] 上面代码中，flat()的参数为2，表示要“拉平”两层的嵌套数组。 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 12[1, [2, [3]]].flat(Infinity)// [1, 2, 3] 如果原数组有空位，flat()方法会跳过空位。 12[1, 2, , 4, 5].flat()// [1, 2, 4, 5] flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。 123// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8] flatMap()只能展开一层数组。 123// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()[1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])// [[2], [4], [6], [8]] 上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此flatMap()返回的还是一个嵌套数组。 flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。 123arr.flatMap(function callback(currentValue[, index[, array]]) &#123; // ...&#125;[, thisArg]) flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。 10 数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 1Array(3) // [, , ,] 上面代码中，Array(3)返回一个具有 3 个空位的数组。 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 120 in [undefined, undefined, undefined] // true0 in [, , ,] // false 上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。 ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 1234567891011121314151617181920212223// forEach方法[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法[,'a'].every(x =&gt; x==='a') // true// reduce方法[1,,2].reduce((x,y) =&gt; x+y) // 3// some方法[,'a'].some(x =&gt; x !== 'a') // false// map方法[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // \"#a##\"// toString方法[,'a',undefined,null].toString() // \",a,,\" ES6 则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 12Array.from(['a',,'b'])// [ \"a\", undefined, \"b\" ] 扩展运算符（...）也会将空位转为undefined。 12[...['a',,'b']]// [ \"a\", undefined, \"b\" ] copyWithin()会连空位一起拷贝。 1[,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"] fill()会将空位视为正常的数组位置。 1new Array(3).fill('a') // [\"a\",\"a\",\"a\"] for...of循环也会遍历空位。 123456let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1 上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 1234567891011121314// entries()[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]// keys()[...[,'a'].keys()] // [0,1]// values()[...[,'a'].values()] // [undefined,\"a\"]// find()[,'a'].find(x =&gt; true) // undefined// findIndex()[,'a'].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。 11 Array.prototype.sort() 的排序稳定性排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变。 1234567891011121314const arr = [ 'peach', 'straw', 'apple', 'spork'];const stableSorting = (s1, s2) =&gt; &#123; if (s1[0] &lt; s2[0]) return -1; return 1;&#125;;arr.sort(stableSorting)// [\"apple\", \"peach\", \"straw\", \"spork\"] 上面代码对数组arr按照首字母进行排序。排序结果中，straw在spork的前面，跟原始顺序一致，所以排序算法stableSorting是稳定排序。 1234567const unstableSorting = (s1, s2) =&gt; &#123; if (s1[0] &lt;= s2[0]) return -1; return 1;&#125;;arr.sort(unstableSorting)// [\"apple\", \"peach\", \"spork\", \"straw\"] 上面代码中，排序结果是spork在straw前面，跟原始顺序相反，所以排序算法unstableSorting是不稳定的。 常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。 早先的 ECMAScript 没有规定，Array.prototype.sort()的默认排序算法是否稳定，留给浏览器自己决定，这导致某些实现是不稳定的。ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定。这个规定已经做到了，现在 JavaScript 各个主要实现的默认排序算法都是稳定的。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"转载","slug":"转载","permalink":"http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"ES6字符串新增方法","slug":"es6-string","date":"2020-10-29T06:30:39.000Z","updated":"2021-12-03T01:42:55.811Z","comments":true,"path":"2020/10/29/es6-string/","link":"","permalink":"http://yoursite.com/2020/10/29/es6-string/","excerpt":"","text":"01 String.fromCodePoint()ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。 12String.fromCharCode(0x20BB7)// \"ஷ\" 上面代码中，String.fromCharCode()不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。 ES6 提供了String.fromCodePoint()方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode()方法的不足。在作用上，正好与下面的codePointAt()方法相反。 1234String.fromCodePoint(0x20BB7)// \"𠮷\"String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'// true 上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 02 String.raw()ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。 12345String.raw`Hi\\n$&#123;2+3&#125;!`// 实际返回 \"Hi\\\\n5!\"，显示的是转义后的结果 \"Hi\\n5!\"String.raw`Hi\\u000A!`;// 实际返回 \"Hi\\\\u000A!\"，显示的是转义后的结果 \"Hi\\u000A!\" 如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。 1234String.raw`Hi\\\\n`// 返回 \"Hi\\\\\\\\n\"String.raw`Hi\\\\n` === \"Hi\\\\\\\\n\" // true String.raw()方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 String.raw()本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值。 123// `foo$&#123;1 + 2&#125;bar`// 等同于String.raw(&#123; raw: ['foo', 'bar'] &#125;, 1 + 2) // \"foo3bar\" 上面代码中，String.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。 作为函数，String.raw()的代码实现基本如下。 12345678910String.raw = function (strings, ...values) &#123; let output = ''; let index; for (index = 0; index &lt; values.length; index++) &#123; output += strings.raw[index] + values[index]; &#125; output += strings.raw[index] return output;&#125; 03 实例方法：codePointAt()JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为·个字节。对于那些需要4个字节储存的字符（Unicode 码点大于·的字符），JavaScript 会认为它们是两个字符。 1234567var s = \"𠮷\";s.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt()方法无法读取整个字符，charCodeAt()方法只能分别返回前两个字节和后两个字节的值。 ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 123456let s = '𠮷a';s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97 codePointAt()方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt()方法的结果与charCodeAt()方法相同。 总之，codePointAt()方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt()方法相同。 codePointAt()方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString()方法转换一下。 1234let s = '𠮷a';s.codePointAt(0).toString(16) // \"20bb7\"s.codePointAt(2).toString(16) // \"61\" 你可能注意到了，codePointAt()方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt()方法传入 2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别 32 位的 UTF-16 字符。 123456let s = '𠮷a';for (let ch of s) &#123; console.log(ch.codePointAt(0).toString(16));&#125;// 20bb7// 61 另一种方法也可以，使用扩展运算符（...）进行展开运算。 123456let arr = [...'𠮷a']; // arr.length === 2arr.forEach( ch =&gt; console.log(ch.codePointAt(0).toString(16)));// 20bb7// 61 codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。 123456function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit(\"𠮷\") // trueis32Bit(\"a\") // false 04 实例方法：normalize()许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。 这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。 1234'\\u01D1'==='\\u004F\\u030C' //false'\\u01D1'.length // 1'\\u004F\\u030C'.length // 2 上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。 ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 12'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize()// true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 12'\\u004F\\u030C'.normalize('NFC').length // 1'\\u004F\\u030C'.normalize('NFD').length // 2 上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。 不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 05 实例方法：includes(), startsWith(), endsWith()传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()： 返回布尔值，表示是否找到了参数字符串。 startsWith()： 返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()： 返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 06 实例方法：repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 123'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\"'na'.repeat(0) // \"\" 参数如果是小数，会被取整。 1'na'.repeat(2.9) // \"nana\" 如果repeat的参数是负数或者Infinity，会报错。 1234'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。 1'na'.repeat(-0.9) // \"\" 参数NaN等同于 0。 1'na'.repeat(NaN) // \"\" 如果repeat的参数是字符串，则会先转换成数字。 12'na'.repeat('na') // \"\"'na'.repeat('3') // \"nanana\" 07 实例方法：padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。 12'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。 12'abc'.padStart(10, '0123456789')// '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 12'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 123'1'.padStart(10, '0') // \"0000000001\"'12'.padStart(10, '0') // \"0000000012\"'123456'.padStart(10, '0') // \"0000123456\" 另一个用途是提示字符串格式。 12'12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\"'09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\" 08 实例方法：trimStart()，trimEnd()ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。 12345const s = ' abc ';s.trim() // \"abc\"s.trimStart() // \"abc \"s.trimEnd() // \" abc\" 上面代码中，trimStart()只消除头部的空格，保留尾部的空格。trimEnd()也是类似行为。 除了空格键，这两个方法对字符串头部（或尾部）的 tab 键、换行符等不可见的空白符号也有效。 浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。 09 实例方法：matchAll()matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。 10 实例方法：replaceAll()历史上，字符串的实例方法replace()只能替换第一个匹配。 12'aabbcc'.replace('b', '_')// 'aa_bcc' 上面例子中，replace()只将第一个b替换成了下划线。 如果要替换所有的匹配，不得不使用正则表达式的g修饰符。 12'aabbcc'.replace(/b/g, '_')// 'aa__cc' 正则表达式毕竟不是那么方便和直观，ES2021 引入了replaceAll()方法，可以一次性替换所有匹配。 12'aabbcc'.replaceAll('b', '_')// 'aa__cc' 它的用法与replace()相同，返回一个新字符串，不会改变原字符串。 1String.prototype.replaceAll(searchValue, replacement) 上面代码中，searchValue是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有g修饰符）。 如果searchValue是一个不带有g修饰符的正则表达式，replaceAll()会报错。这一点跟replace()不同。 12345// 不报错'aabbcc'.replace(/b/, '_')// 报错'aabbcc'.replaceAll(/b/, '_') 上面例子中，/b/不带有g修饰符，会导致replaceAll()报错。 replaceAll()的第二个参数replacement是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。 $&amp;：匹配的子字符串。 `$`：匹配结果前面的文本。 $&#39;：匹配结果后面的文本。 $n：匹配成功的第n组内容，n是从1开始的自然数。 $$：指代美元符号$。 12'abc'.replaceAll('b', '$$')// 'a$c' 上面例子中，$$表示替换的文本是单个美元符号$。 replaceAll()的第二个参数replacement除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数searchValue匹配的文本。 12'aabbcc'.replaceAll('b', () =&gt; '_')// 'aa__cc' 上面例子中，replaceAll()的第二个参数是一个函数，该函数的返回值会替换掉所有b的匹配。 这个替换函数可以接受多个参数。第一个参数是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。 123456789const str = '123abc456';const regex = /(\\d+)([a-z]+)(\\d+)/g;function replacer(match, p1, p2, p3, offset, string) &#123; return [p1, p2, p3].join(' - ');&#125;str.replaceAll(regex, replacer)// 123 - abc - 456 上面例子中，正则表达式有三个组匹配，所以replacer()函数的第一个参数match是捕捉到的匹配内容（即字符串123abc456），后面三个参数p1、p2、p3则依次为三个组匹配。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"转载","slug":"转载","permalink":"http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"}]},{"title":"你知道该如何在前端实现文件的下载吗","slug":"download","date":"2020-09-02T07:53:44.000Z","updated":"2023-05-16T01:32:38.263Z","comments":true,"path":"2020/09/02/download/","link":"","permalink":"http://yoursite.com/2020/09/02/download/","excerpt":"","text":"01 前言下载是网页上常见的功能，那从后端获取数据后该如何创建下载链接呢，一般来说有两种情况： 后台返回下载链接 后台返回文件内容 那这两种情况分别应该如何处理呢，下面我们来详细讨论下 02 后台返回下载链接直接返回下载链接的情况相对比较简单，只需要创建a标签，并执行点击事件就可以触发下载事件了 「实现」 1234567//msg.url为后台获取的下载地址const atag:any = document.createElementNS(\"http://www.w3.org/1999/xhtml\",'a');atag.href = msg.url;atag.download = 'filename';atag.click();URL.revokeObjectURL(atag.href); 若返回的链接为http://xxx.xxx.doc等带文件后缀的形式，想要修改文件名保存，那需要先获取此文件的blob，通常此情况是aws的S3，阿里云的OSS下载 1234567891011fetch(fileUrl) .then(res =&gt; res.blob()) .then(blob =&gt; &#123; const url = window.URL.createObjectURL(new Blob([blob])); const atag = document.createElement('a'); atag.href = url; atag.download = 'fileName'; let event = new MouseEvent(\"click\"); atag.dispatchEvent(event); window.URL.revokeObjectURL(url); &#125;) 03 后台返回文件内容后台返回的是文件内容，就需要将文件内容转化为Blob对象，再利用saveAs方法对文件进行下载，当然也同样可以创建a标签，利用点击事件出发下载 「实现」 1234567891011//msg.content为后台获取的文件内容const content = new Blob([msg.content]);saveAs(content,'file-name');//orconst atag:any = document.createElementNS(\"http://www.w3.org/1999/xhtml\",'a');atag.href = URL.createObjectURL(content);atag.download = 'filename';atag.click();URL.revokeObjectURL(atag.href); 如果这是个pdf文件内容，你可以使用以下方法直接查看 1234const content = new Blob([msg.content], &#123;type: 'application/pdf'&#125;);let pdfURL = URL.createObjectURL(content);window.open(pdfURL);URL.revokeObjectURL(pdfURL);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"应用","slug":"应用","permalink":"http://yoursite.com/tags/%E5%BA%94%E7%94%A8/"}]},{"title":"谈谈你对重绘和回流的理解","slug":"backflow-repaint","date":"2020-08-24T02:56:28.000Z","updated":"2021-12-03T01:40:36.829Z","comments":true,"path":"2020/08/24/backflow-repaint/","link":"","permalink":"http://yoursite.com/2020/08/24/backflow-repaint/","excerpt":"","text":"01 前言重回和回流是老生常谈的问题了，了解他们之前我们先来了解一下浏览器渲染流水线，这里就不详细展开了，不了解同学可以去看看我的关于浏览器访问的文章 浏览器渲染流水线 02 回流回流也叫 重排。简单来说，就是当我们对DOM 结构的修改引发DOM 几何尺寸变化的时候，会发生回流的过程。 触发条件以下的操作会触发回流: 一个 DOM 元素的几何属性变化，常见的几何属性有width、height、padding、margin、left、top、border 等等, 这个很好理解。 使 DOM 节点发生增减或者移动。 读写 offset族、scroll族和client族属性的时候，浏览器为了获取这些值，需要进行回流操作。 调用 window.getComputedStyle 方法。 回流过程 回流过程 依照上面的渲染流水线，触发回流的时候，DOM 结构发生改变，重新渲染 DOM 树，然后将后面的流程(包括主线程之外的任务)全部走一遍。 相当于将解析和合成的过程重新又走了一篇，开销是非常大的。 03 重绘简单来说，当DOM 样式改变，几何属性不发生改变的时候，会发生重绘(repaint)的过程。 触发条件 当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候。 重绘过程 重绘过程 由于没有导致 DOM 几何属性的变化，因此元素的位置信息不需要更新，从而省去布局的过程。跳过了生成布局树和建图层树的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。 可以看到，重绘不一定导致回流，但回流一定发生了重绘。 04 合成 —— GPU加速利用 CSS3 的transform、opacity、filter这些属性就可以实现合成的效果，也就是大家常说的GPU加速。 GPU加速的原因: 在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给合成线程处理。交给它处理有两大好处: 能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。 05 实践意义知道上面的原理之后，对于开发过程有什么指导意义呢？ 避免频繁使用style，而是采用修改class的方式。 使用createDocumentFragment进行批量的 DOM 操作。 对于resize、scroll 等进行防抖/节流处理。 添加will-change: tranform，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于tranform, 任何可以实现合成效果的 CSS 属性都能用will-change来声明。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"重绘和回流","slug":"重绘和回流","permalink":"http://yoursite.com/tags/%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/"}]},{"title":"从输入URL到页面呈现到底发生了些什么","slug":"browser-access","date":"2020-08-10T02:16:00.000Z","updated":"2021-12-03T01:41:23.763Z","comments":true,"path":"2020/08/10/browser-access/","link":"","permalink":"http://yoursite.com/2020/08/10/browser-access/","excerpt":"","text":"01 前言作为一个合格的前端工程师，浏览器相关的工作原理是我们进行性能优化的基石，了解浏览器原理也是前端系统知识体系中的重要一环。 你了解从输入URL地址到页面呈现，究竟发生了什么呢，本节将分网络请求与响应，算法解析，渲染三个过程来讲解。 02 网络请求与响应1. 浏览器构建请求行12GET / HTTP/2//GET是请求方法，/为根路径，HTTP/2为版本协议 2. 查找缓存依次检查强缓存，以及协商缓存，如果缓存有效则直接使用，否则进入下一步 3. DNS解析我们输入的URL地址是域名，而数据包是通过IP地址传递的。因此需要通过 DNS域名系统 进行解析,将域名和IP地址一一对应 当然浏览器也提供了 DNS数据缓存功能 如果一个域名已经解析过了，下次访问则直接使用缓存的IP地址，无需重新解析 IP地址默认对应80端口 4. 建立TCP链接 TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 建立TCP连接需要经历三个阶段： 通过 三次握手 (即总共发送3个数据包确认已经建立连接)建立客户端和服务器之间的连接。 连接建立后，需要进行数据传输。传输过程必须进行 数据包校验，即接收方接收到数据包后必须要向发送方确认, 如果发送方没有接到这个确认的消息，就判定为数据包丢失，并重新发送该数据包。发送过程有一个优化策略，把大数据包拆成一个个小包，依次传输到接收方，接收方按顺序把它们组装成完整数据包。 数据传输完成后，通过 四次挥手 来断开连接。 5. 发送HTTP请求TCP连接建立完毕后，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。浏览器发 HTTP 请求要携带三样东西: 请求行、请求头 和 请求体。 请求行在第一步就已经构建完成 请求头中包括我们之前说的Cache-Control、If-Modified-Since、If-None-Match都可能存在 请求体，只有在POST请求中才会存在 6.网络相应HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。跟请求类似，网络响应具有三个部分:响应行、响应头 和 响应体。 响应头由HTTP协议版本、状态码和状态描述组成。 1HTTP/2 200 OK 响应完成后，TCP连接就断开了吗？ 请求头或响应头中包含了Connection字段，如果值为Keep-Alive，表示建立了持久连接，这样TCP连接会一直保持，之后请求统一站点的资源会复用这个连接。 否则断开TCP连接, 请求-响应流程结束。 03 算法解析完成了网络请求和响应，如果响应头中Content-Type值是text/html，那么接下来就是浏览器的解析和渲染工作了。 解析部分主要分为以下几个步骤: 构建 DOM 树(DOM Tree) 样式计算 生成布局树(Layout Tree) 生成图层树(Layer Tree) 1. 构建 DOM 树(DOM Tree)由于浏览器无法直接理解HTML字符串因此需要将这一系列的字节流转换为别的数据结构，即DOM树。DOM树本质上是一个以document为根节点的多叉树。 常规的编程语言都是上下文无关文法，而HTML却是它 非上下文无关文法 的特性，决定了HTML Parser并不能使用常规编程语言的解析器来完成。 HTML5 规范详细地介绍了解析算法。这个算法分为两个阶段: 标记化。 建树。 标记化算法这个算法输入为HTML文本，输出为HTML标记，也称为 标记生成器。运用有限自动状态机来完成。即在当当前状态下，接收一个或多个字符，就会更新到下一个状态。 遇到&lt;, 状态为 标记打开。 接收[a-z]的字符，会进入 标记名称状态。 这个状态一直保持，直到遇到&gt;，表示标记名称记录完成，这时候变为 数据状态。 建树算法前面说过 DOM 树是一个以document为根节点的多叉树，因此解析器首先会创建一个document对象。标记生成器会把每个标记的信息发送给 建树器。建树器接收到相应的标记时，会创建对应的 DOM 对象。创建这个DOM对象后会做两件事情: 将DOM对象加入 DOM 树中。 将对应标记压入存放开放(与闭合标签意思对应)元素的栈中。 2. 样式计算CSS样式一般有三种来源： link标签引用 style标签中的样式 元素的内嵌style属性 无论是那种来源的css样式文本，都是无法被浏览器直接识别的，因此浏览器会对css样式文本做以下操作： 格式化将css样式文本转化为多个 styleSheet 对象，通过document.styleSheets可查看这些对象。 标准化一些 CSS 样式的数值并不被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如em-&gt;px,red-&gt;#ff0000等。 计算样式节点计算方式主要是两个规则: 继承 和 层叠。计算完后，所有的样式值会被挂在到window.getComputedStyle(element)中。 3. 生成布局树(Layout Tree)布局树生成的大致工作如下: 遍历生成的 DOM 树节点，并把他们添加到布局树中。 计算布局树节点的坐标位置。 值得注意的是，布局树值只包含可见元素，对于&lt;head&gt;和display: none的元素，将不会被放入其中。 4. 生成图层树(Layer Tree)一些复杂的场景，如3D动画等，元素含有层叠上下文时，需要构建一棵 图层树(Layer Tree) 来控制不同层元素的显示和隐藏等等。 一般情况下，节点的图层会默认属于父亲节点的图层，即 合成层。那什么时候会提升为一个单独的合成层呢？ 一般有两种情况： 显式合成 隐式合成 显示合成显示合成一般出现在两种情况下： 拥有 层叠上下文 的节点，一般通过css属性创建，常见情况有： HTML根元素； 设置了z-index属性； opacity 值不为 1； transform 值不为 none； filter 值不为 none； isolation 值为 isolate|auto； will-change 值为z-index|opacity|transform|filter|isolation之一。 超出裁剪如一个设置了大小的元素中，放了非常多的文字，那么超出的文字部分就需要被剪裁，从而提升为一个新图层。当然如果出现了滚动条，滚动条也会被提升为一个新图层。 隐式合成隐式合成，简单来说就是 层叠等级低 的节点被提升为单独的图层之后，所有层叠等级比它高的节点都会成为一个单独的图层。 隐式合成隐藏着巨大的风险，如果在一个大型应用中，当一个z-index比较低的元素被提升为单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接让页面崩溃。这就是 层爆炸 的原理。 值得注意的是，当需要重绘时，只需要重绘显式合成图层本身，而不会影响到其他的隐式合成的图层。 04 渲染渲染主要分为以下几个步骤: 生成绘制列表 生成图块并栅格化 显示器显示内容 1. 生成绘制列表渲染引擎会将图层的绘制拆分成一个个绘制指令，将这些指令按顺序组合成一个待绘制列表。 绘制列表可以在 Chrome 开发者工具中在设置栏中展开 more tools, 然后选择Layers面板看到 Layers面板 2. 生成图块和生成位图渲染进程中绘制操作是由专门的线程来完成的，这个线程叫 合成线程。绘制列表准备好了之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给合成线程。 通常情况下，页面大小远大于视窗大小，如果一口气全部绘制出来是相当浪费性能的。因此，合成线程要做的第一件事情就是将 图层分块。这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。 视窗外的图块数据存入 GPU 内存，由于浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。因此针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个低分辨率的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。顺便提醒一点，渲染进程中专门维护了一个栅格化线程池，专门负责把图块转换为位图数据。然后合成线程会选择视口附近的图块，把它交给栅格化线程池生成位图。生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给合成线程。 3. 显示器显示内容栅格化操作完成后，合成线程会生成一个绘制命令，即”DrawQuad”，并发送给浏览器进程。浏览器进程中的viz组件接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡。为什么发给显卡呢？我想有必要先聊一聊显示器显示图像的原理。无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。看到这里你也就是明白，当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"请求流程","slug":"请求流程","permalink":"http://yoursite.com/tags/%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/"},{"name":"渲染流程","slug":"渲染流程","permalink":"http://yoursite.com/tags/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"}]},{"title":"浏览器的缓存原理，你都知道吗","slug":"browser-cache","date":"2020-08-10T02:11:31.000Z","updated":"2021-12-03T01:41:49.174Z","comments":true,"path":"2020/08/10/browser-cache/","link":"","permalink":"http://yoursite.com/2020/08/10/browser-cache/","excerpt":"","text":"01 前言作为一个合格的前端工程师，浏览器相关的工作原理是我们进行性能优化的基石，了解浏览器原理也是前端系统知识体系中的重要一环。 那关于浏览器的缓存你知道多少呢，本文将详细的来聊一聊浏览器的缓存问题 02 浏览器的缓存缓存是性能优化中非常重要的一环，浏览器的缓存机制对开发也是非常重要的知识点。浏览器的缓存分为强缓存和协商缓存两种。 强缓存 检查阶段无需发送HTTP请求，直接通过服务器返回的响应头中相应的字段来检查是否有效的缓存称为强缓存。 检查字段存在于服务器返回的响应头中，告诉浏览器在过期时间前可以直接从缓存中获取数据，无需再次请求，在早期HTTP/1.0时代，该字段为Expires，而HTTP/1.1以后使用的是Cache-Control。 Expires1Expires: Tue, 16 Jun 2020 15:08:00 GMT 表示资源有效期到2020年6月16号15点08分，过了有效期就需要重新想服务器请求资源。由于服务器的时间和浏览器的时间可能并不一致，因此这种方式返回的过期时间可能并不准确，在HTTP1.1版本中就抛弃了。 Cache-Control1Cache-Control:max-age=3600 表示资源在3600s之内都可以直接使用。它和Expires本质的不同在于它并没有采用具体的过期时间这个方式，而是采用过期时长来控制缓存。 Cache-Control可以与多个指令结合 public: 客户端和代理服务器都可以缓存。 private: 只有浏览器能缓存了，中间的代理服务器不能缓存。 no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。 no-store: 非常粗暴，不进行任何形式的缓存。 s-maxage: 这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。 值得注意当Expires与Cache-Control同时存在时，优先考虑Cache-Control。 协商缓存 强缓存失效之后，浏览器在请求头中携带相应的缓存tag来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是协商缓存。 协商缓存tag分为两种: Last-Modified 和 ETag Last-Modified即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。浏览器接收到后，再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是最后修改时间。 服务器拿到请求头中的 If-Modified-Since 的字段后，会和服务器中该资源的最后修改时间对比: 如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。 否则返回304，告诉浏览器直接用缓存 ETagETag 是服务器根据当前文件内容，给文件生成的唯一标识，文件内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器，浏览器接收到ETag值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，放在请求头中发送给服务器。 服务器接收到 If-None-Match 后，会跟服务器上该资源的 ETag 值进行比对: 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。 否则返回304，告诉浏览器直接用缓存。 两者对比在精准度上，ETag 优于 Last-Modified。ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 是针对最后的修改时间，在一些特殊的情况并不能准确感知资源变化，主要有两种情况: 编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。 Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。 在性能上，Last-Modified 优于 ETag。如果两种方式都支持的话，服务器会优先考虑 ETag 缓存位置前面我们已经提到，当强缓存有效或者协商缓存中服务器返回304时，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？ 浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是： Service Worker Cache - 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外 Memory Cache - 内存缓存，效率最快，存活时间最短，渲染进程结束后，内存缓存也就不存在了 Disk Cache - 磁盘缓存，效率比内存缓存慢，存储容量大和存储时间长，存放大的JS、CSS文件，以及内存使用率高时的文件 Push Cache - 即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容 03 总结浏览器的缓存机制: 首先通过 Cache-Control 验证强缓存是否可用，如果强缓存可用，直接使用 进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的If-Modified-Since或者If-None-Match字段检查资源是否更新 若资源更新，返回资源和200状态码，否则返回304，告诉浏览器直接从缓存获取资源","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"}],"tags":[{"name":"缓存策略","slug":"缓存策略","permalink":"http://yoursite.com/tags/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"}]},{"title":"详细的谈一谈apply, call, bind","slug":"call-apply-bind","date":"2020-08-03T07:51:22.000Z","updated":"2021-08-06T02:02:25.359Z","comments":true,"path":"2020/08/03/call-apply-bind/","link":"","permalink":"http://yoursite.com/2020/08/03/call-apply-bind/","excerpt":"","text":"01 前言这又是一个面试经典问题，也是 ES5 中众多坑中的一个。虽然在 ES6 中可能会极大避免 this 产生的错误，但是为了一些老代码的维护，详细的了解一下 this 的指向和 call、apply、bind 三者的区别还是很有必要的。 02 this的指向了解call，apply，bind之前我们先来了解下js中 this 的指向。其实 this 的指向，始终坚持一个原理： this 永远指向最后调用它的那个对象。 下面我们就来讨论下这些场隐式绑定的场景this指向: 全局上下文 直接调用函数 对象.方法的形式调用 DOM事件绑定(特殊) new构造函数绑定 箭头函数 全局上下文全局上下文默认this指向window, 严格模式下指向undefined。 直接调用函数1234567let obj = &#123; a: function() &#123; console.log(this); &#125;&#125;let func = obj.a;func(); 这种直接调用函数的情况。this相当于全局上下文的情况，默认指向window。 对象.方法 调用123456let obj = &#123; a: function() &#123; console.log(this); &#125;&#125;obj.a(); 这种对象.方法的调用情况。this指向的是这个对象。 DOM事件绑定12&lt;div&gt;&lt;/div&gt;&lt;button onclick=\"myClick()\"&gt;123&lt;/button&gt; 12345678let dom = document.querySelector('div');dom.addEventerListener('click',function()&#123; console.log(this);&#125;);function myClick()&#123; console.log(this);&#125; addEventerListener中 this 默认指向绑定事件的元素。 onclick等系列事件和IE中使用的attachEvent默认this指向window。 new构造函数12345function Person(name) &#123; this.name = name; this.age = 6;&#125;let tz = new Person('Tz'); 此时构造函数中的this指向实例对象(tz)。 箭头函数箭头函数没有this, 因此也不能绑定。里面的this会指向当前最近的非箭头函数的this，找不到就是window(严格模式是undefined)。 123456789let obj = &#123; a: function() &#123; let do = () =&gt; &#123; console.log(this); &#125; do(); &#125;&#125;obj.a(); this找到最近的非箭头函数是a方法，a现在绑定着obj, 因此箭头函数中的this是obj。 03 apply，call，bindbind，call，apply都是用于显性的绑定this，从而改变this的指向。 applyMDN给出的定义是： apply() 方法调用一个函数, 其具有一个指定的this值，以及作为 一个数组（或类似数组的对象） 提供的参数 语法： func.apply(thisArg, [argsArray]) thisArg 必选。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 argsArray 可选。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 1234567891011function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(arr) &#123; Product.apply(this, arr); //this指向实例对象food this.category = 'food';&#125;let food = new Food(['cheese', 5]) callMDN给出的定义是： call() 方法使用一个指定的 this 值和单独给出的 一个或多个参数 来调用一个函数。 语法： function.call(thisArg, arg1, arg2, …) thisArg 可选。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 arg1, arg2, ... 指定的参数列表。 1234567891011function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; Product.call(this, name, price); //this指向实例对象food this.category = 'food';&#125;let food = new Food('cheese', 5); bindMDN给出的定义是： bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 语法： function.bind(thisArg[, arg1[, arg2[, …]]]) thisArg 调用绑定函数时作为 this 参数传递给目标函数的值。 如果使用new运算符构造绑定函数，则忽略该值。当使用 bind 在 setTimeout 中创建一个函数（作为回调提供）时，作为 thisArg 传递的任何原始值都将转换为 object。如果 bind 函数的参数列表为空，或者thisArg是null或undefined，执行作用域的 this 将被视为新函数的 thisArg。 arg1, arg2, ... 当目标函数被调用时，被预置入绑定函数的参数列表中的参数。 1234567891011function Product(name, price) &#123; this.name = name; this.price = price;&#125;function Food(name, price) &#123; Product.bind(this, name, price)(); //this指向实例对象food this.category = 'food';&#125;let food = new Food('cheese', 5); 三者区别 apply 使用 数组 作为参数； call 使用 参数列表 作为参数； bind 使用 参数列表 作为参数，且创建了一个新的函数，需要 被调用 才会起作用。 04 手写模拟实现apply方法1234567891011121314151617181920Function.prototype.myapply = function (thisArg, args) &#123; thisArg = Object(thisArg) || window; let fn = Symbol(); thisArg[fn] = this; let result = thisArg[fn](...args); delete thisArg[fn]; return result;&#125;//testlet obj = &#123; a: 1&#125;function test(x1, x2) &#123; console.log(x1, x2) //2, 3 console.log(this.a) //1&#125;test.myapply(obj, [2, 3]) 05 手写模拟实现call方法1234567891011121314151617181920Function.prototype.mycall = function (thisArg, ...args) &#123; thisArg = Object(thisArg) || window; let fn = Symbol(); thisArg[fn] = this; let result = thisArg[fn](...args); delete thisArg[fn]; return result;&#125;//testlet obj = &#123; a: 1&#125;function test(x1, x2) &#123; console.log(x1, x2) //2, 3 console.log(this.a) //1&#125;test.mycall(obj, 2, 3) 06 手写模拟实现bind方法12345678910111213141516Function.prototype.mybind = function(thisArg, ...args)&#123; return (...newArgs) =&gt; &#123; return this.call(thisArg, ...args, ...newArgs) &#125;&#125;// testlet obj = &#123; a: 1&#125;function test(x1, x2) &#123; console.log(x1, x2) //2, 3 console.log(this.a) //1&#125;test.mybind(obj, 2, 3)()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"手写API","slug":"手写API","permalink":"http://yoursite.com/tags/%E6%89%8B%E5%86%99API/"}]},{"title":"说一说 CSRF 攻击","slug":"csrf","date":"2020-07-30T01:52:43.000Z","updated":"2021-12-03T01:39:55.950Z","comments":true,"path":"2020/07/30/csrf/","link":"","permalink":"http://yoursite.com/2020/07/30/csrf/","excerpt":"","text":"01 前言Web开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。今天我们就来了解下 CSRF 攻击。 02 什么是 CSRF 攻击CSRF 全称是 Cross-site request forgery，翻译过来就是 “跨站请求伪造”，是指引诱用户打开第三方网站，在第三方网站中利用用户的登录状态发起的跨站请求。 一般的情况下，点开一个诱导你的链接，黑客会在你不知情的时候做哪些事情呢？ 1.自动发起 Get 请求黑客网页里面可能有一段这样的代码 1&lt;img src=\"https://xxx.com/info?user=xxx&amp;count=100\"&gt; 在用户访问含有这个img的页面后，浏览器会自动向 https://xxx.com 发送 Get 请求。如果用户已经登录，那么此次请求将会带上 cookie 信息。 假如服务器端没有相应的验证机制，那么服务器会认为发请求的是一个正常的用户。因为携带了相应的 cookie，具有进行相应操作的权限，那么黑客就可以进行转账汇款等恶意操作。 2.自动发起 Post 请求黑客可能自己填了一个表单，写了一段自动提交的脚本。 12345&lt;form id='hacker-form' action=\"https://xxx.com/info\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"user\" value=\"xxx\" /&gt; &lt;input type=\"hidden\" name=\"count\" value=\"100\" /&gt;&lt;/form&gt;&lt;script&gt;document.getElementById('hacker-form').submit();&lt;/script&gt; 同样也会携带相应的用户 cookie 信息，让服务器误以为是一个正常的用户在操作，让各种恶意的操作变为可能。 3.诱导点击发送 GET 请求这种需要诱导用户去点击链接才会触发，这类的情况比如在论坛中发布照片，照片中嵌入了恶意链接，或者是以广告的形式去诱导，比如： 1&lt;a href=\"https://xxx/info?user=xxx&amp;count=100\" taget=\"_blank\"&gt;enter&lt;a/&gt; 用户点击后，自动发送 get 请求，后续操作 自动发 GET 请求 部分同理。 以上三种情况，就是 CSRF 攻击原理，跟 XSS 对比的话，CSRF 攻击并不需要将恶意代码注入 HTML 中，而是跳转新的页面，利用 服务器的验证漏洞 和 用户之前的登录状态 来模拟用户进行操作 03 如何防范 CSRF 攻击从 CSRF 的攻击原理中我们不难发现，黑客只能借助用户的 cookie 骗取服务器的信任，但由于浏览器同源策略的限制，黑客并不能对cookie的内容进行解析。 这就告诉我们，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行CSR的保护。而保护的关键是 在请求中放入黑客所不能伪造的信息，即 用户操作的验证机制 1.验证站点来源在服务器端验证请求来源的站点，由于大量的CSRF攻击来自第三方站点，因此可以设置服务器跨域禁止来自第三方站点的请求，主要通过HTTP请求头中的两个字段 Origin Referer 其中，Origin 只包含域名信息，而 Referer 包含了具体的URL 路径。服务器可以通过解析这两个Header中的域名，确定请求的来源域。 但是这两者都是可以伪造的，通过AJax中自定义请求头即可，因此安全性略差。 2.利用Cookie的SameSite属性SameSite可以设置为三个值：Strict、Lax和None。 在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求xxx.com网站只能在xxx.com域名当中请求才能携带 Cookie，在其他网站请求都不能。 在Lax模式，就宽松一点了，但是只能在get 方法提交表单或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。 在None模式下，Cookie将在所有上下文中发送，即允许跨域发送。 3.CSRF TokenToken(令牌)做为Web领域验证身份是一个不错的选择，Token的步骤如下： 第一步: 将CSRF Token输出到页面中。 第二步: 页面提交的请求携带这个Token。 第三步: 服务器验证Token是否正确，如果不合法则不予响应。 04 总结CSRF(Cross-site request forgery), 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户目前的登录状态发起跨站请求。 CSRF攻击一般会有三种方式: 自动 GET 请求 自动 POST 请求 诱导点击发送 GET 请求 防范措施: 验证来源站点 利用 Cookie 的 SameSite 属性 CSRF Token。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"web攻击","slug":"web攻击","permalink":"http://yoursite.com/tags/web%E6%94%BB%E5%87%BB/"}]},{"title":"谈一谈XSS攻击","slug":"xss","date":"2020-07-29T02:22:31.000Z","updated":"2021-08-06T02:02:32.482Z","comments":true,"path":"2020/07/29/xss/","link":"","permalink":"http://yoursite.com/2020/07/29/xss/","excerpt":"","text":"01 前言Web开发离不开安全这个话题，确保网站或者网页应用的安全性，是每个开发人员都应该了解的事。今天我们就来了解下XSS攻击。 02 什么是 XSS 攻击XSS 全称是 Cross Site Scripting ,为了与CSS区分开来，故简称 XSS，翻译过来就是 “跨站脚本”。 XSS是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，在用户浏览页面时利用注入的恶意脚本对用户实施攻击，从而拿到用户的信息并进行操作。 最开始的时候，这种攻击是通过跨域来实现的，所以叫“跨域脚本”。发展到现在，往HTML文件中中插入恶意代码方式越来越多，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。 注入恶意脚本可以完成这些事情： 窃取Cookie 监听用户行为，比如用户输入账号密码后直接发给黑客服务器 在网页中生成浮窗广告 修改DOM伪造登入表单 一般的情况下，XSS攻击有三种实现方式： 存储型 XSS 攻击 反射型 XSS 攻击 文档型 XSS 攻击 存储型 XSS 攻击 存储型XSS 从图上看，存储型 XSS 攻击大致步骤如下： 黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中； 用户向网站请求了包含恶意 JavaScript 脚本的页面； 在用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到恶意服务器上。 常见的场景是在评论区提交一份脚本代码，如果前后端没有做好转义工作直接上传到了服务器，那么在页面渲染的时候就会直接执行，相当于执行一段未知的JS代码，这是相当不安全的。 反射型 XSS 攻击反射型 XSS 指的是恶意脚本作为 网络请求的参数 。经过服务器，然后再反射到HTML文档中，执行解析。和存储型XSS攻击不一样的是，服务器并不会存储这些恶意脚本。 举个例子： 1http:&#x2F;&#x2F;sanyuan.com?a&#x3D;&lt;script&gt;alert(&quot;反射型XSS攻击&quot;)&lt;&#x2F;script&gt; 在服务器端会拿到a参数,然后将内容返回给浏览器端，浏览器将这些内容作为HTML的一部分解析，发现是一个脚本，直接执行，这样就被攻击了。 文档型 XSS 攻击文档型的 XSS 攻击是一共基于 DOM 的 XSS 攻击，它不会经过服务端。黑客通过各种手段将恶意脚本注入用户页面 DOM 中，在数据传输的时候劫持网络数据包 常见的劫持方式有： WIFI路由器劫持 本地恶意软件 03 如何防范 XSS 攻击明白了三种 XSS 攻击的原理，我们能发现一个共同点: 都是让 恶意脚本直接能在浏览器中执行。 那么要防范它，就是要避免这些脚本代码的执行。 为了完成这一点，常见的防范措施有： 对输入脚本进行过滤或转码 利用CSP 利用HttpOnly 「对输入脚本进行过滤或转码」本着千万不要相信任何用户输入的信念，无论是在前端和服务端，都要对用户的输入进行转码或者过滤。 举个例子👇： 12&lt;div&gt;XSS攻击&lt;/div&gt;&lt;script&gt;alert('你受到XSS攻击了')&lt;/script&gt; 转码后： 12&amp;lt;div&amp;gt;XSS攻击&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt;alert(&amp;#39;你受到XSS攻击了&amp;#39;)&amp;lt;/script&amp;gt; 这样的代码在 html 解析的过程中是无法执行的。 当然也可以利用关键词过滤的方式，将&lt;script&gt;、&lt;img&gt;、&lt;a&gt;等关键字标签给删除。那么现在的内容只剩下: 1&lt;div&gt;XSS攻击&lt;/div&gt; 「利用 CSP」CSP，即浏览器中的内容安全策略，它的核心思想是 服务器决定浏览器加载哪些资源，具体来说具有一下几个功能👇 限制加载其他域下的资源文件； 禁止向其他域提交数据； 提供上报机制，能帮助我们及时发现 XSS 攻击。 禁止执行内联脚本和未授权的脚本； 「利用 HttpOnly」由于绝大多数 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。 HttpOnly 是服务器通过 HTTP 响应头来设置的，设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值。这样也能很好的防范 XSS 攻击。 04 总结XSS 攻击是指浏览器中执行恶意脚本, 然后拿到用户的信息进行操作。主要分为 存储型、反射型和文档型。 防范的措施包括: 对输入内容过滤或者转码，尤其是类似于&lt;script&gt;、&lt;img&gt;、&lt;a&gt;标签 利用CSP 利用Cookie的HttpOnly属性 除了以上策略之外，我们还可以通过添加验证码防止脚本冒充用户提交危险操作。而对于一些不受信任的输入，还可以限制其输入长度，这样可以增大 XSS 攻击的难度。","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"web攻击","slug":"web攻击","permalink":"http://yoursite.com/tags/web%E6%94%BB%E5%87%BB/"}]},{"title":"谈一谈跨域，以及跨域解决方法","slug":"cross-origin","date":"2020-07-24T02:33:03.000Z","updated":"2021-12-03T01:42:29.444Z","comments":true,"path":"2020/07/24/cross-origin/","link":"","permalink":"http://yoursite.com/2020/07/24/cross-origin/","excerpt":"","text":"01 前言跨域是几乎我们在请求数据是都会遇到问题，那究竟什么是跨域，又如何解决呢？话不多说我们直接开始。 02 同源策略同源策略 是一个安全策略。所谓的同源,指的是协议,域名,端口相同。 同源策略 同源策略限制了一下行为： Cookie、LocalStorage、SessionStorage 和 IndexDB 无法读取 DOM 和 JS 对象无法获取 Ajax 请求发送不出去 03 什么是跨域跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。 04 解决方法JSONP跨域JSONP跨域是利用script标签src没有跨域限制的漏洞，将前端方法作为参数传递到服务器端，由服务器端注入参数后返回，实现服务器端向客户端通信。「实现」 创建script标签 设置script标签的src属性，以问号传递参数，设置好回调函数callback名称 插入html文本中 调用回调函数，res参数就是获取的数据 123456789let script = document.createElement('script');script.src = 'http://www.xxx.com/login?username=xxx&amp;callback=callback';document.body.appendChild(script);function callback(res) &#123; console.log(res);&#125; jquery方法 123456789$.ajax(&#123; url: 'http://www.baidu.cn/login', type: 'GET', dataType: 'jsonp', //请求方式为jsonp jsonpCallback: 'callback', data: &#123; \"username\": \"xxx\" &#125;&#125;) 「JSONP的优点」 它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持 它在请求完毕后可以通过调用callback的方式回传结果。 「JSONP的缺点」 它只支持GET请求，具有局限性，不安全，可能会受到XSS攻击 它只能解决跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题 跨域资源共享CORS1.什么是CORS CORS（Cross-Origin Resource Sharing）跨域资源共享，是一个W3C的标准。CORS背后的基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。 CORS需要浏览器和服务器同时支持。目前，虽然所有浏览器都支持该功能，但IE8/9需要使用XDomainRequest对象来支持CORS。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于前端开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器，服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符(*)则表示所有网站都可以访问资源。 2.简单请求与非简单请求CORS通行的这种方式分为两种请求：一种是 简单请求，另一种是 非简单请求，浏览器对这两种请求方式的处理方式是不同的。 所谓的简单请求，就是满足一下条件的请求，反之则为非简单请求。 条件1：请求方式为以下三者之一 GET HEAD POST 条件2：Content-Type 的值仅限于下列三者之一 text/plain multipart/form-data application/x-www-form-urlencoded 「简单请求」对于简单请求，浏览器直接发出CORS请求。具体来说，就是浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 1Origin: http://localhost:5678 Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源不在许可范围内，服务器会返回一个正常的HTTP响应，但响应头信息没有包含Access-Control-Allow-Origin字段，从而抛出一个错误被XMLHttpRequest的onerror回调函数捕获。 注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的源在许可范围内，服务器返回的响应，会多出几个头信息字段： 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin: 必须。它的值要么是请求时Origin字段的值，要么是一个表示接受任意域名的请求。 Access-Control-Allow-Credentials: 可选。它是一个布尔值且只能为true，表示允许浏览器发送Cookie。默认情况下，Cookie不包括在CORS请求之中。如果服务器不允许浏览器发送Cookie，删除该字段即可。 Access-Control-Expose-Headers: 可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。 需要注意的是，如果需要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且跨源原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 「非简单请求」 非简单请求一般对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，Content-Type字段的类型是application/json等。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为 “预检”请求(preflight)。 该请求的方法是OPTIONS方法，浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 WebSocket协议跨域Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。 WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种 双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。虽然 WebSocket 在建立连接时需要借助 HTTP 协议，但连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 来看下面这个例子 client向localhost:5678发送数据和接受数据👇 123456789101112131415let socket = new WebSocket('ws://localhost:5678');socket.onopen = ()=&gt; &#123; socket.send('test');//向服务器发送数据&#125;socket.onmessage = (e)=&gt; &#123; console.log(e.data);//接收服务器返回的数据&#125;socket.onclose = (e)=&gt; &#123; //当客户端收到服务端发送的关闭连接请求时，触发onclose事件 console.log(\"close\");&#125;socket.onerror = (e)=&gt; &#123; //如果出现连接、处理、接收、发送数据失败的时候触发onerror事件 console.log(error);&#125; 后端部分👇 123456789// server.jsconst WebSocket = require('ws');let socketServer = new WebSocket.Server(&#123;port:5678&#125;);socketServer.on('connection',(ws)=&gt; &#123; ws.on('message', (data)=&gt; &#123; console.log(data); ws.send('server data') &#125;);&#125;); 想要深入了解WebSocket，可以尝试使用Socket.io nginx代理跨域1.nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot/otf/ttf/woff/svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 123location / &#123; add_header Access-Control-Allow-Origin *;&#125; 2.nginx反向代理接口跨域「原理」同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，因此不需要同源策略，也就不存在跨越问题。 「实现」通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx配置👇 12345678910111213#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 #add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 前端部分👇 12345678let xhr = new XMLHttpRequest();// set browser read/write cookiexhr.withCredentials = true;// open nginx proxyxhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send(); 后端部分👇 1234567891011121314const http = require('http');const qs = require('querystring');let server = http.createServer();server.on('request', (req, res)=&gt; &#123; let params = qs.parse(req.url.substring(2)); // write cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080'); nginx参考","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]}],"categories":[{"name":"进阶应用","slug":"进阶应用","permalink":"http://yoursite.com/categories/%E8%BF%9B%E9%98%B6%E5%BA%94%E7%94%A8/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"V8引擎工作原理","slug":"V8引擎工作原理","permalink":"http://yoursite.com/categories/V8%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"网络安全","slug":"网络安全","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"部署","slug":"部署","permalink":"http://yoursite.com/tags/%E9%83%A8%E7%BD%B2/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"},{"name":"应用","slug":"应用","permalink":"http://yoursite.com/tags/%E5%BA%94%E7%94%A8/"},{"name":"浏览器工作原理","slug":"浏览器工作原理","permalink":"http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"name":"易考点","slug":"易考点","permalink":"http://yoursite.com/tags/%E6%98%93%E8%80%83%E7%82%B9/"},{"name":"转载","slug":"转载","permalink":"http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"重绘和回流","slug":"重绘和回流","permalink":"http://yoursite.com/tags/%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81/"},{"name":"请求流程","slug":"请求流程","permalink":"http://yoursite.com/tags/%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/"},{"name":"渲染流程","slug":"渲染流程","permalink":"http://yoursite.com/tags/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/"},{"name":"缓存策略","slug":"缓存策略","permalink":"http://yoursite.com/tags/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"},{"name":"手写API","slug":"手写API","permalink":"http://yoursite.com/tags/%E6%89%8B%E5%86%99API/"},{"name":"网络安全","slug":"网络安全","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"web攻击","slug":"web攻击","permalink":"http://yoursite.com/tags/web%E6%94%BB%E5%87%BB/"}]}